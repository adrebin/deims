<?php
/**
 * @file
 * Code for the Data Source Content Type feature.
 */

include_once 'deims_data_source.features.inc';

/**
 * Implements hook_field_extra_fields().
 */
function deims_data_source_field_extra_fields() {
  $info['node']['data_source']['form']['deims_data_source_preview_csv'] = array(
    'label' => t('Preview CSV file'),
    'weight' => 0,
  );
  $info['node']['data_source']['form']['deims_data_source_parse_csv_to_variables'] = array(
    'label' => t('Parse CSV file into variables'),
    'weight' => 0,
  );

  return $info;
}

/**
 * Implements hook_field_attach_form().
 */
function deims_data_source_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  if ($entity_type == 'node' && $form['#bundle'] == 'data_source') {
    list($id) = entity_extract_ids($entity_type, $entity);

    $form['deims_data_source_preview_csv'] = array(
      '#type' => 'submit',
      '#value' => t('Preview CSV file'),
      '#limit_validation_errors' => array(
        array_merge($form['#parents'], array('field_data_source_file', $form['field_data_source_file']['#language'])),
        array_merge($form['#parents'], array('field_csv_orientation', $form['field_csv_orientation']['#language'])),
        array_merge($form['#parents'], array('field_csv_field_delimiter', $form['field_csv_field_delimiter']['#language'])),
        array_merge($form['#parents'], array('field_csv_header_lines', $form['field_csv_header_lines']['#language'])),
        array_merge($form['#parents'], array('field_csv_footer_lines', $form['field_csv_footer_lines']['#language'])),
      ),
      '#submit' => array('deims_data_source_preview_csv_submit'),
      '#ajax' => array(
        'callback' => 'deims_data_source_preview_csv_js',
        'wrapper' => 'data-source-preview',
      ),
      '#attached' => array(
        'library' => array(
          array('system', 'ui.dialog'),
        ),
        'js' => array(
          drupal_get_path('module', 'deims_data_source') . '/js/data_source.js' => array(),
        ),
      ),
      '#attributes' => array(
        'class' => array('data-source-preview-button'),
      ),
      // Provide a div for the source preview.
      '#prefix' => '<div id="data-source-preview"></div>',
    );

    $wrapper_parents = $form['#parents'];
    $wrapper_parents[] = 'field-variables-add-more-wrapper';
    $wrapper_id = drupal_html_class(implode('-', $wrapper_parents));
    $form['deims_data_source_parse_csv_to_variables'] = array(
      '#type' => 'submit',
      '#value' => t('Parse CSV file into variables'),
      '#limit_validation_errors' => array(
        array_merge($form['#parents'], array('field_data_source_file', $form['field_data_source_file']['#language'])),
        array_merge($form['#parents'], array('field_csv_orientation', $form['field_csv_orientation']['#language'])),
        array_merge($form['#parents'], array('field_csv_field_delimiter', $form['field_csv_field_delimiter']['#language'])),
        array_merge($form['#parents'], array('field_csv_header_lines', $form['field_csv_header_lines']['#language'])),
      ),
      '#submit' => array('deims_data_source_parse_csv_to_variables_submit'),
      '#ajax' => array(
        'callback' => 'deims_data_source_parse_csv_to_variables_js',
        'wrapper' => $wrapper_id,
      ),
      '#access' => empty($id) && $form['field_variables'][$form['field_variables']['#language']]['#cardinality'] == FIELD_CARDINALITY_UNLIMITED && empty($form_state['programmed']),
    );
  }
}

function deims_data_source_parse_csv_to_variables_submit(&$form, &$form_state) {
  $button = $form_state['triggering_element'];

  // Go one level up in the form, to the entity container.
  $entity_parents = $button['#array_parents'];
  array_pop($entity_parents);

  // Extract the data source submitted field values.
  $values = drupal_array_get_nested_value($form_state['values'], $entity_parents);

  $fid = $values['field_data_source_file'][LANGUAGE_NONE][0]['fid'];
  $options = array(
    'orientation' => $values['field_csv_orientation'][LANGUAGE_NONE][0]['value'],
    'delimiter' => $values['field_csv_field_delimiter'][LANGUAGE_NONE][0]['value'],
    'header lines' => !empty($values['field_csv_header_lines'][LANGUAGE_NONE][0]['value']) ? $values['field_csv_header_lines'][LANGUAGE_NONE][0]['value'] : 0,
    // We don't care about actual data, so don't return me any actual rows.
    'limit' => 0,
    // We don't want the default headers.
    'default headers' => FALSE,
  );

  $result = deims_data_source_get_csv_table($fid, $options);
  if (!empty($result['header'])) {
    $headers = $result['header'];

    // Navigate to the field_variables field.
    $variable_parents = $entity_parents;
    $variable_parents[] = 'field_variables';
    $variable_parents[] = LANGUAGE_NONE;
    $variable_element = drupal_array_get_nested_value($form, $variable_parents);

    $field_name = $variable_element['#field_name'];
    $langcode = $variable_element['#language'];
    $field_parents = $variable_element['#field_parents'];

    // First we need to set the correct amount of field values in the field
    // form state.
    $field_state = field_form_get_state($field_parents, $field_name, $langcode, $form_state);
    $field_state['items_count'] = count($headers);
    field_form_set_state($field_parents, $field_name, $langcode, $form_state, $field_state);

    // Next build the form state values and save them to both form values and
    // form input so that the form rebuild will display our custom values now.
    $values = array();
    $delimiters_csv=array('pair'=>';','key_value'=>'|');  //Delimiters in the CSV file
    $delimiters_form=array('pair'=>"\n",'key_value'=>'|'); //Delimiters used in the form
    $options_field = module_exists('options_element');  //Options Element module adds an 'options_elelment' key.
    foreach ($headers as $delta => $header) {
      //parse out the type of data and the units or code pairs from the CSV file.
	// Pattern for: physical variables is unit:name_of_unit;max|value;min|value;precision|value
	// coded variables codes:key|value;key|value and so on for as many key|value pairs
	// date variables  date:date format
	// missing values pairs  code|reason  Note: missing values and code pairs are separated by ';' in the CSV file 
	//          but the form needs them in 'code|reason /n' 'code|reason /n'  format. 
        
        if ($options_field)   {
          $missing['options_field']=str_replace($delimiters_csv,$delimiters_form,$header['missing_values']);   
        }else {
            $missing=str_replace($delimiters_csv,$delimiters_form,$header['missing_values']);
        }
        //Parse out the type of data and values
        if (strpos($header['data'], ':') ){
            list($data_type,$data_values)= explode(':',$header['data']);
        } else {
            $data_type="";
        }
        $data=array();
        Switch ($data_type) {
           case 'codes':
               if ($options_field) {
                   $data['codes']['options_field']= str_replace($delimiters_csv,$delimiters_form,$data_values);
               }else {
                   $data['codes']= str_replace($delimiters_csv,$delimiters_form,$data_values);
               }
               break;
           case 'unit':
               $data_pair=explode(';',$data_values);
               $data_type= 'physical';
               $data['unit']['select']='select_or_other';  //DEIMS uses the select_or_other module for units. to add it need other.
               $data['unit']['other']= $data_pair[0];
               $data['maximum']=isset($data_pair[1]) ? substr($data_pair[1], strpos($data_pair[1], '|') + 1):""; //only get the value of pair
               $data['minimum']=isset($data_pair[2]) ? substr($data_pair[2], strpos($data_pair[2], '|') + 1):"";
               $data['precision']=isset($data_pair[3]) ? substr($data_pair[3], strpos($data_pair[3], '|') + 1):"";
               break;  
           case 'date':
               $data['pattern']=$data_values;
               break;      
       }      
        
      $values[] = array(
        'id' => NULL,
        'name' => $header['label'],
        'label' => $header['label'],
        'definition' => $header['description'],
        'type' => $data_type,
        'data'=>$data,
        'missing_values'=>$missing,
        
        //'_weight' => $delta,
      );
    }
    drupal_array_set_nested_value($form_state['values'], $variable_parents, $values);
    drupal_array_set_nested_value($form_state['input'], $variable_parents, $values);

    // Next make sure that the form gets rebuilt so that our form values are
    // displayed.
    $form_state['rebuild'] = TRUE;
  }
  else {
    drupal_set_message(t('Unable to fetch CSV headers.'), 'error');
  }
}

function deims_data_source_parse_csv_to_variables_js($form, $form_state) {
  $button = $form_state['triggering_element'];

  $parents = $button['#array_parents'];
  array_pop($parents);
  $parents[] = 'field_variables';
  $parents[] = LANGUAGE_NONE;

  // Go one level up in the form, to the widgets container.
  $element = drupal_array_get_nested_value($form, $parents);
  $field_name = 'field_variables'; //$element['#field_name'];
  $langcode = LANGUAGE_NONE; //$element['#language'];
  $parents = array(); //$element['#field_parents'];

  return $element;
}

function deims_data_source_preview_csv_submit(&$form, &$form_state) {
  $button = $form_state['triggering_element'];

  // Go one level up in the form, to the widgets container.
  $parents = $button['#array_parents'];
  array_pop($parents);

  $element = &drupal_array_get_nested_value($form, $parents);
  $values = drupal_array_get_nested_value($form_state['values'], $parents);

  $fid = $values['field_data_source_file'][LANGUAGE_NONE][0]['fid'];

  $options = array();
  $options['delimiter'] = $values['field_csv_field_delimiter'][LANGUAGE_NONE][0]['value'];
  $options['orientation'] = $values['field_csv_orientation'][LANGUAGE_NONE][0]['value'];
  $options['header lines'] = !empty($values['field_csv_header_lines'][LANGUAGE_NONE][0]['value']) ? $values['field_csv_header_lines'][LANGUAGE_NONE][0]['value'] : 0;
  $options['footer lines'] = !empty($values['field_csv_footer_lines'][LANGUAGE_NONE][0]['value']) ? $values['field_csv_footer_lines'][LANGUAGE_NONE][0]['value'] : 0;

  $result = deims_data_source_get_csv_table($fid, $options);

  // Disable deafult sorting in the datatable to show the records in order.
  $result['attributes']['datatable_options']['aaSorting'] = array();

  $output = theme('datatable', $result);
  $element['deims_data_source_preview_csv']['#prefix'] = '<div id="data-source-preview"><div class="data-source-preview-modal">' . $output . '</div>';
}

/**
 * Generate a datatable from a given CSV source preview.
 */
function deims_data_source_preview_csv_js($form, $form_state) {
  $button = $form_state['triggering_element'];

  // Go one level up in the form, to the entity container.
  $parents = $button['#array_parents'];
  array_pop($parents);

  $element = drupal_array_get_nested_value($form, $parents);
  return $element['deims_data_source_preview_csv']['#prefix'];
}

/**
 * Read a CSV file and return output that could be used in theme_table().
 *
 * @param int $fid
 *   A file ID.
 * @param array $options
 *   An optional array of options:
 *   - header lines: The number of header lines to expect in the CSV file
 *   - footer lines: The number of footer lines to expect in the CSV file
 *   - orientation: The orientation of the data in the CSV file, either 'column'
 *     for normal CSV files where each column is a field, or...
 *   - delimiter: The field delimiter to use when calling fgetcsv()
 *   - default headers: If the headers are empty, provide a default header in
 *     the format of 'Column 1' and 'Column 2'.
 *   - limit: The maximum number of rows to return.
 *
 * @return array
 *   An array that can be passed directly into theme('table').
 */
function deims_data_source_get_csv_table($fid, array $options = array()) {
  $options += array(
    'header lines' => $options['header lines'],
    'footer lines' => 0,
    'orientation' => 'column',
    'delimiter' => ',',
    'default headers' => TRUE,
    'limit' => variable_get('data_source_preview_limit', 100),
  );
    
  $result = array(
    'header' => array('label'=>array(),'description'=>array(),'data'=>array(),'missing_values'=>array()),
    'rows' => array(),
  );

  if ($file = file_load($fid)) {
    $csv = fopen(drupal_realpath($file->uri), 'r');

    $row_count = 0;
    while (($line = fgetcsv($csv, 0, $options['delimiter'])) !== FALSE) {
      $row_count++;

      // Sanity check.
      if ($row_count <= ($options['limit'] + $options['header lines'])) {
        if ($options['orientation'] == 'column') {
          // Are we adding just 1 header line? If not then assign lines to correct header array.
          switch ($row_count) {
              case 1:
                $result['header']['label']=$line; 
                break;
              case 2:
                $result['header']['description']=$line;
                break;                  
              case 3:
                $result['header']['data']= $line;
                break;
              case 4:
                $result['header']['missing_values']=$line;
                break;
              default:
                array_push($result['rows'], $line);  
          } 
        }
        else {
          // Each new line represents data for records defined in columns.
          foreach ($line as $key => $field) {
            if ($options['header lines'] == 1 && $key == 0) {
              $result['header'][] = $field;
            }
            else {
              $result['rows'][$key][] = $field;
            }
          }
        }
      }

      // Super insanity check.
      if (($row_count - $options['header lines']) >= $options['limit']) {
        break;
      }
    }

    fclose($csv);
  }
//rearrange array of headers so that each variable key includes all the info. The switch is using follow through 
 $vari_list = array();
 foreach($result['header']['label']as $key=>$var_label){
     switch ($options['header lines']){
         case 4:
            $vari_list[$key]['missing_values']=$result['header']['missing_values'][$key];
         case 3:
            $vari_list[$key]['data']=$result['header']['data'][$key];
         case 2:
            $vari_list[$key]['description']=$result['header']['description'][$key];
         case 1:     
            $vari_list[$key]['label'] =$result['header']['label'][$key];}
         
 }
 $result['header']= $vari_list;
  // Do we need to remove any footer lines?
  $remove = count($result['rows']) - $options['header lines'] - $options['footer lines'];
  if ($remove < $options['limit']) {
    array_splice($result['rows'], $remove);
  }

  // If the headers are not available, then fill in a 'default' header for each
  // column.
  if (!empty($options['default headers']) && empty($result['header'])) {
    for ($i = 1; $i <= count($result['rows'][0]); $i++) {
      $result['header'][] = array('data' => t('Column @num', array('@num' => $i)));
    }
  }

  return $result;
}
